#' Overall results summary with adaptive stopping probabilities for clinical trial data
#'
#' This function calculates futility and efficacy stopping probabilities for adaptive
#' clinical trial designs based on data generated by \code{\link{overallSummary}}.
#' It provides both interim-specific and cumulative stopping probabilities along with
#' descriptive statistics for each analysis timepoint.
#'
#' @param data A data.table containing overall summary data generated by \code{\link{overallSummary}}.
#'   Must contain columns: simID, analysis, analysis_time, lr_statistic, lr_pvalue,
#'   hazard_ratio, n_total, n_control, n_treatment, events_total, events_control, events_treatment.
#' @param futility_bounds A numeric vector specifying the futility stopping boundaries
#'   for each analysis. Length must match the number of analyses. Use NA to skip
#'   futility assessment at specific analyses.
#' @param futility_bounds_type A character string specifying the type of futility boundary.
#'   Must be one of "hr" (hazard ratio), "test_statistic" (log-rank statistic), or
#'   "p_val" (p-value).
#' @param efficacy_bounds A numeric vector specifying the efficacy stopping boundaries
#'   for each analysis. Length must match the number of analyses. Use NA to skip
#'   efficacy assessment at specific analyses.
#' @param efficacy_bounds_type A character string specifying the type of efficacy boundary.
#'   Must be one of "test_statistic" (log-rank statistic) or "p_val" (p-value).
#'
#' @return A data.table containing overall results summary with the following columns:
#' \describe{
#'   \item{analysis}{Analysis number}
#'   \item{analysis_time}{Mean analysis cutoff time across simulations}
#'   \item{n_total}{Mean total number of patients across simulations}
#'   \item{n_control}{Mean number of patients in control group across simulations}
#'   \item{n_treatment}{Mean number of patients in treatment group across simulations}
#'   \item{events_total}{Mean total number of events across simulations}
#'   \item{events_control}{Mean number of events in control group across simulations}
#'   \item{events_treatment}{Mean number of events in treatment group across simulations}
#'   \item{prob_futility_stop}{Probability of futility stopping at this analysis}
#'   \item{cumu_prob_futility_stop}{Cumulative probability of futility stopping up to this analysis}
#'   \item{prob_efficacy_stop}{Probability of efficacy stopping at this analysis}
#'   \item{cumu_prob_efficacy_stop}{Cumulative probability of efficacy stopping up to this analysis}
#' }
#'
#' @details
#' This function implements adaptive trial stopping rules by:
#'
#' \describe{
#'   \item{Futility Stopping}{
#'     Based on the specified futility_bounds_type:
#'     \itemize{
#'       \item "hr": Stop if hazard_ratio > futility_bounds
#'       \item "test_statistic": Stop if lr_statistic > futility_bounds
#'       \item "p_val": Stop if lr_pvalue > futility_bounds
#'     }
#'   }
#'   \item{Efficacy Stopping}{
#'     Based on the specified efficacy_bounds_type:
#'     \itemize{
#'       \item "test_statistic": Stop if lr_statistic < efficacy_bounds
#'       \item "p_val": Stop if lr_pvalue < efficacy_bounds
#'     }
#'   }
#'   \item{Trial Continuation}{
#'     Trial continues to next analysis only if neither futility nor efficacy
#'     stopping criteria are met at the current analysis.
#'   }
#' }
#'
#' The function processes simulations sequentially through analyses, tracking
#' which trials stop at each timepoint and calculating both interim and cumulative
#' stopping probabilities.
#'
#' @examples
#' library(data.table)
#'
#' # Generate trial data
#' trial_data <- simTrial(
#'   nsim = 1000,
#'   N = list(control = 100, treatment = 100),
#'   a.time = list(control = c(0, 18), treatment = c(0, 18)),
#'   intensity = list(control = 100/18, treatment = 100/18),
#'   e.time = list(control = c(0, Inf), treatment = c(0, Inf)),
#'   e.hazard = list(control = 0.08, treatment = 0.05),
#'   d.time = list(control = c(0, Inf), treatment = c(0, Inf)),
#'   d.hazard = list(control = 0.01, treatment = 0.01),
#'   seed = 123
#' )
#'
#' # Create analysis datasets
#' analysis_data <- analysisData(trial_data, E = c(50, 100, 150))
#'
#' # Generate overall summary
#' overall_data <- overallSummary(analysis_data, control = 1, side = 1, hr_est_method = "LR")
#'
#' # Define stopping boundaries
#' futility_bounds <- c(0.8, NA, 1.2)  # HR-based futility at analyses 1 and 3
#' efficacy_bounds <- c(NA, 0.025, 0.05)  # p-value-based efficacy at analyses 2 and 3
#'
#' # Calculate stopping probabilities
#' results <- overallResults(
#'   data = overall_data,
#'   futility_bounds = futility_bounds,
#'   futility_bounds_type = "hr",
#'   efficacy_bounds = efficacy_bounds,
#'   efficacy_bounds_type = "p_val"
#' )
#'
#' print(results)
#'
#' @seealso
#' \code{\link{overallSummary}} for generating the input overall summary data,
#' \code{\link{analysisData}} for creating analysis datasets
#'
#' @import data.table
#' @export
overallResults <- function(data, futility_bounds, futility_bounds_type,
                           efficacy_bounds, efficacy_bounds_type) {
  # Input validation
  if (!is.data.table(data)) {
    data <- as.data.table(data)
  }

  required_cols <- c("simID", "analysis", "analysis_time", "lr_statistic",
                     "lr_pvalue", "hazard_ratio", "n_total", "n_control",
                     "n_treatment", "events_total", "events_control", "events_treatment")
  missing_cols <- setdiff(required_cols, names(data))
  if (length(missing_cols) > 0) {
    stop(paste("Missing required columns:", paste(missing_cols, collapse = ", ")))
  }

  # Validate bounds vectors
  if (length(futility_bounds) != length(efficacy_bounds)) {
    stop("futility_bounds and efficacy_bounds must have the same length")
  }

  n_analyses <- length(futility_bounds)
  unique_analyses <- sort(unique(data$analysis))
  if (length(unique_analyses) != n_analyses) {
    stop("Number of analyses in data does not match length of bounds vectors")
  }

  # Validate bounds types
  valid_futility_types <- c("hr", "test_statistic", "p_val")
  if (!futility_bounds_type %in% valid_futility_types) {
    stop(paste("futility_bounds_type must be one of:", paste(valid_futility_types, collapse = ", ")))
  }

  valid_efficacy_types <- c("test_statistic", "p_val")
  if (!efficacy_bounds_type %in% valid_efficacy_types) {
    stop(paste("efficacy_bounds_type must be one of:", paste(valid_efficacy_types, collapse = ", ")))
  }

  # Set key for optimal performance
  setkeyv(data, c("simID", "analysis"))

  n_sims <- length(unique(data$simID))

  # Create a simulation tracking table
  sim_status <- data.table(
    simID = unique(data$simID),
    stopped = FALSE,
    stop_analysis = NA_integer_,
    stop_reason = NA_character_
  )
  setkey(sim_status, simID)

  # Arrays to store stopping counts by analysis
  futility_stops <- rep(0, n_analyses)
  efficacy_stops <- rep(0, n_analyses)

  # Process each analysis
  for (i in seq_len(n_analyses)) {
    # Get active simulations (not yet stopped)
    active_sims <- sim_status[stopped == FALSE, simID]

    if (length(active_sims) == 0) {
      next
    }

    # Get current analysis data for active simulations only
    current_data <- data[analysis == i & simID %in% active_sims]

    if (nrow(current_data) == 0) {
      next
    }

    # Check futility stopping
    futility_stopped <- integer(0)
    if (!is.na(futility_bounds[i])) {
      if (futility_bounds_type == "hr") {
        condition <- current_data$hazard_ratio > futility_bounds[i]
      } else if (futility_bounds_type == "test_statistic") {
        condition <- current_data$lr_statistic > futility_bounds[i]
      } else if (futility_bounds_type == "p_val") {
        condition <- current_data$lr_pvalue > futility_bounds[i]
      }
      futility_stopped <- current_data[condition == TRUE, simID]
    }

    # Check efficacy stopping (for non-futility stopped simulations)
    efficacy_stopped <- integer(0)
    if (!is.na(efficacy_bounds[i])) {
      remaining_data <- current_data[!simID %in% futility_stopped]
      if (nrow(remaining_data) > 0) {
        if (efficacy_bounds_type == "test_statistic") {
          condition <- remaining_data$lr_statistic < efficacy_bounds[i]
        } else if (efficacy_bounds_type == "p_val") {
          condition <- remaining_data$lr_pvalue < efficacy_bounds[i]
        }
        efficacy_stopped <- remaining_data[condition == TRUE, simID]
      }
    }

    # Update simulation status
    if (length(futility_stopped) > 0) {
      sim_status[simID %in% futility_stopped, `:=`(
        stopped = TRUE,
        stop_analysis = i,
        stop_reason = "futility"
      )]
    }

    if (length(efficacy_stopped) > 0) {
      sim_status[simID %in% efficacy_stopped, `:=`(
        stopped = TRUE,
        stop_analysis = i,
        stop_reason = "efficacy"
      )]
    }

    # Store counts
    futility_stops[i] <- length(futility_stopped)
    efficacy_stops[i] <- length(efficacy_stopped)
  }

  # Calculate descriptive statistics by analysis
  descriptive_stats <- data[, .(
    analysis_time = mean(analysis_time, na.rm = TRUE),
    n_total = mean(n_total, na.rm = TRUE),
    n_control = mean(n_control, na.rm = TRUE),
    n_treatment = mean(n_treatment, na.rm = TRUE),
    events_total = mean(events_total, na.rm = TRUE),
    events_control = mean(events_control, na.rm = TRUE),
    events_treatment = mean(events_treatment, na.rm = TRUE)
  ), by = analysis]

  # Create stopping probabilities table
  stopping_probs <- data.table(
    analysis = seq_len(n_analyses),
    prob_futility_stop = futility_stops / n_sims,
    prob_efficacy_stop = efficacy_stops / n_sims
  )

  # Calculate cumulative stopping probabilities
  stopping_probs[, `:=`(
    cumu_prob_futility_stop = cumsum(prob_futility_stop),
    cumu_prob_efficacy_stop = cumsum(prob_efficacy_stop)
  )]

  # Merge results
  final_results <- descriptive_stats[stopping_probs, on = "analysis"]

  # Set column order
  setcolorder(final_results, c("analysis", "analysis_time", "n_total", "n_control",
                               "n_treatment", "events_total", "events_control",
                               "events_treatment", "prob_futility_stop",
                               "cumu_prob_futility_stop", "prob_efficacy_stop",
                               "cumu_prob_efficacy_stop"))

  return(final_results)
}
