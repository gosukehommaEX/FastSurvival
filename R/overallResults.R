#' Overall results summary with adaptive stopping probabilities for clinical trial data
#'
#' This function calculates futility and efficacy stopping probabilities for adaptive
#' clinical trial designs based on data generated by \code{\link{overallSummary}}.
#' It provides both interim-specific and cumulative stopping probabilities along with
#' descriptive statistics for each analysis timepoint.
#'
#' @param data A tibble containing overall summary data generated by \code{\link{overallSummary}}.
#'   Must contain columns: simID, analysis, analysis_time, lr_statistic, lr_pvalue,
#'   hazard_ratio, n_total, n_control, n_treatment, events_total, events_control, events_treatment.
#' @param futility_bounds A numeric vector specifying the futility stopping boundaries
#'   for each analysis. Length must match the number of analyses. Use NA to skip
#'   futility assessment at specific analyses.
#' @param futility_bounds_type A character string specifying the type of futility boundary.
#'   Must be one of "hr" (hazard ratio), "test_statistic" (log-rank statistic), or
#'   "p_val" (p-value).
#' @param efficacy_bounds A numeric vector specifying the efficacy stopping boundaries
#'   for each analysis. Length must match the number of analyses. Use NA to skip
#'   efficacy assessment at specific analyses.
#' @param efficacy_bounds_type A character string specifying the type of efficacy boundary.
#'   Must be one of "test_statistic" (log-rank statistic) or "p_val" (p-value).
#'
#' @return A tibble containing overall results summary with the following columns:
#' \describe{
#'   \item{analysis}{Analysis number}
#'   \item{analysis_time}{Mean analysis cutoff time across simulations}
#'   \item{n_total}{Mean total number of patients across simulations}
#'   \item{n_control}{Mean number of patients in control group across simulations}
#'   \item{n_treatment}{Mean number of patients in treatment group across simulations}
#'   \item{events_total}{Mean total number of events across simulations}
#'   \item{events_control}{Mean number of events in control group across simulations}
#'   \item{events_treatment}{Mean number of events in treatment group across simulations}
#'   \item{prob_futility_stop}{Probability of futility stopping at this analysis}
#'   \item{cumu_prob_futility_stop}{Cumulative probability of futility stopping up to this analysis}
#'   \item{prob_efficacy_stop}{Probability of efficacy stopping at this analysis}
#'   \item{cumu_prob_efficacy_stop}{Cumulative probability of efficacy stopping up to this analysis}
#' }
#'
#' @details
#' This function implements adaptive trial stopping rules by:
#'
#' \describe{
#'   \item{Futility Stopping}{
#'     Based on the specified futility_bounds_type:
#'     \itemize{
#'       \item "hr": Stop if hazard_ratio > futility_bounds
#'       \item "test_statistic": Stop if lr_statistic > futility_bounds
#'       \item "p_val": Stop if lr_pvalue > futility_bounds
#'     }
#'   }
#'   \item{Efficacy Stopping}{
#'     Based on the specified efficacy_bounds_type:
#'     \itemize{
#'       \item "test_statistic": Stop if lr_statistic < efficacy_bounds
#'       \item "p_val": Stop if lr_pvalue < efficacy_bounds
#'     }
#'   }
#'   \item{Trial Continuation}{
#'     Trial continues to next analysis only if neither futility nor efficacy
#'     stopping criteria are met at the current analysis.
#'   }
#' }
#'
#' The function processes simulations sequentially through analyses, tracking
#' which trials stop at each timepoint and calculating both interim and cumulative
#' stopping probabilities.
#'
#' @examples
#' library(dplyr)
#'
#' # Generate trial data
#' trial_data <- simTrial(
#'   nsim = 100,
#'   n = list(
#'     control = c(A = 25, B = 112, C = 113),
#'     treatment = c(A = 25, B = 112, C = 113)
#'   ),
#'   a.time = c(0, 12.5),
#'   intensity = 40,
#'   e.time = list(
#'     control = list(A = c(0, Inf), B = c(0, Inf), C = c(0, Inf)),
#'     treatment = list(A = c(0, Inf), B = c(0, Inf), C = c(0, Inf))
#'   ),
#'   e.hazard = list(
#'     control = list(A = log(2) / 4.3, B = log(2) / 4.3, C = log(2) / 4.3),
#'     treatment = list(A = log(2) / 5.811, B = log(2) / 5.811, C = log(2) / 5.811)
#'   ),
#'   d.time = NULL,
#'   d.hazard = NULL,
#'   seed = 1
#' )
#'
#' # Create analysis datasets
#' analysis_data <- analysisData(trial_data, E = c(141, 246, 352))
#'
#' # Generate overall summary
#' overall_data <- overallSummary(analysis_data, control = 1, side = 1, hr_est_method = "LR")
#'
#' # Define stopping boundaries
#' futility_bounds <- c(0.788, NA, -2)  # HR-based futility at analyses 1 and 3
#' efficacy_bounds <- c(NA, -2.44, -2)  # p-value-based efficacy at analyses 2 and 3
#'
#' # Calculate stopping probabilities
#' results <- overallResults(
#'   data = overall_data,
#'   futility_bounds = futility_bounds,
#'   futility_bounds_type = "test_statistic",
#'   efficacy_bounds = efficacy_bounds,
#'   efficacy_bounds_type = "test_statistic"
#' )
#'
#' print(results)
#'
#' @seealso
#' \code{\link{overallSummary}} for generating the input overall summary data,
#' \code{\link{analysisData}} for creating analysis datasets
#'
#' @import dplyr
#' @export
overallResults <- function(data, futility_bounds, futility_bounds_type,
                           efficacy_bounds, efficacy_bounds_type) {
  # Input validation
  if (!inherits(data, c("tbl_df", "tbl", "data.frame"))) {
    stop("data must be a tibble or data.frame generated by overallSummary")
  }

  required_cols <- c("simID", "analysis", "analysis_time", "lr_statistic",
                     "lr_pvalue", "hazard_ratio", "n_total", "n_control",
                     "n_treatment", "events_total", "events_control", "events_treatment")
  missing_cols <- setdiff(required_cols, names(data))
  if (length(missing_cols) > 0) {
    stop(paste("Missing required columns:", paste(missing_cols, collapse = ", ")))
  }

  # Validate bounds vectors
  if (length(futility_bounds) != length(efficacy_bounds)) {
    stop("futility_bounds and efficacy_bounds must have the same length")
  }

  n_analyses <- length(futility_bounds)
  unique_analyses <- sort(unique(data$analysis))
  if (length(unique_analyses) != n_analyses) {
    stop("Number of analyses in data does not match length of bounds vectors")
  }

  # Validate bounds types
  valid_futility_types <- c("hr", "test_statistic", "p_val")
  if (!futility_bounds_type %in% valid_futility_types) {
    stop(paste("futility_bounds_type must be one of:", paste(valid_futility_types, collapse = ", ")))
  }

  valid_efficacy_types <- c("test_statistic", "p_val")
  if (!efficacy_bounds_type %in% valid_efficacy_types) {
    stop(paste("efficacy_bounds_type must be one of:", paste(valid_efficacy_types, collapse = ", ")))
  }

  # Get unique simulation IDs
  sim_ids <- unique(data$simID)
  n_sims <- length(sim_ids)

  # Create simulation tracking table
  sim_status <- tibble(
    simID = sim_ids,
    stopped = FALSE,
    stop_analysis = NA_integer_,
    stop_reason = NA_character_
  )

  # Process each analysis to determine stopping
  for (analysis_num in seq_len(n_analyses)) {
    # Get active simulations (not yet stopped)
    active_sims <- sim_status %>%
      filter(!stopped) %>%
      pull(simID)

    if (length(active_sims) == 0) {
      next
    }

    # Get current analysis data for active simulations only
    current_data <- data %>%
      filter(analysis == analysis_num, simID %in% active_sims)

    if (nrow(current_data) == 0) {
      next
    }

    # Check futility stopping
    futility_stopped <- c()
    if (!is.na(futility_bounds[analysis_num])) {
      futility_condition <- evaluate_futility_condition(
        current_data, futility_bounds[analysis_num], futility_bounds_type
      )
      futility_stopped <- current_data$simID[futility_condition]
    }

    # Check efficacy stopping (for non-futility stopped simulations)
    efficacy_stopped <- c()
    if (!is.na(efficacy_bounds[analysis_num])) {
      remaining_data <- current_data %>%
        filter(!simID %in% futility_stopped)

      if (nrow(remaining_data) > 0) {
        efficacy_condition <- evaluate_efficacy_condition(
          remaining_data, efficacy_bounds[analysis_num], efficacy_bounds_type
        )
        efficacy_stopped <- remaining_data$simID[efficacy_condition]
      }
    }

    # Update simulation status
    if (length(futility_stopped) > 0) {
      sim_status <- sim_status %>%
        mutate(
          stopped = ifelse(simID %in% futility_stopped, TRUE, stopped),
          stop_analysis = ifelse(simID %in% futility_stopped, analysis_num, stop_analysis),
          stop_reason = ifelse(simID %in% futility_stopped, "futility", stop_reason)
        )
    }

    if (length(efficacy_stopped) > 0) {
      sim_status <- sim_status %>%
        mutate(
          stopped = ifelse(simID %in% efficacy_stopped, TRUE, stopped),
          stop_analysis = ifelse(simID %in% efficacy_stopped, analysis_num, stop_analysis),
          stop_reason = ifelse(simID %in% efficacy_stopped, "efficacy", stop_reason)
        )
    }
  }

  # Calculate descriptive statistics by analysis
  descriptive_stats <- data %>%
    group_by(analysis) %>%
    summarise(
      analysis_time = mean(analysis_time, na.rm = TRUE),
      n_total = mean(n_total, na.rm = TRUE),
      n_control = mean(n_control, na.rm = TRUE),
      n_treatment = mean(n_treatment, na.rm = TRUE),
      events_total = mean(events_total, na.rm = TRUE),
      events_control = mean(events_control, na.rm = TRUE),
      events_treatment = mean(events_treatment, na.rm = TRUE),
      .groups = 'drop'
    )

  # Calculate stopping probabilities
  stopping_summary <- sim_status %>%
    group_by(stop_analysis, stop_reason) %>%
    summarise(n_stopped = n(), .groups = 'drop') %>%
    complete(stop_analysis = seq_len(n_analyses), stop_reason = c("futility", "efficacy"),
             fill = list(n_stopped = 0)) %>%
    pivot_wider(names_from = stop_reason, values_from = n_stopped,
                names_prefix = "n_", values_fill = 0) %>%
    rename(analysis = stop_analysis) %>%
    mutate(
      prob_futility_stop = n_futility / n_sims,
      prob_efficacy_stop = n_efficacy / n_sims,
      cumu_prob_futility_stop = cumsum(prob_futility_stop),
      cumu_prob_efficacy_stop = cumsum(prob_efficacy_stop)
    ) %>%
    select(analysis, prob_futility_stop, cumu_prob_futility_stop,
           prob_efficacy_stop, cumu_prob_efficacy_stop)

  # Merge results
  final_results <- descriptive_stats %>%
    left_join(stopping_summary, by = "analysis") %>%
    # Replace NA values with 0 for stopping probabilities
    mutate(
      prob_futility_stop = ifelse(is.na(prob_futility_stop), 0, prob_futility_stop),
      cumu_prob_futility_stop = ifelse(is.na(cumu_prob_futility_stop), 0, cumu_prob_futility_stop),
      prob_efficacy_stop = ifelse(is.na(prob_efficacy_stop), 0, prob_efficacy_stop),
      cumu_prob_efficacy_stop = ifelse(is.na(cumu_prob_efficacy_stop), 0, cumu_prob_efficacy_stop)
    )

  return(final_results)
}

# Helper function: Evaluate futility condition
evaluate_futility_condition <- function(data, bound, type) {
  switch(type,
         "hr" = !is.na(data$hazard_ratio) & data$hazard_ratio > bound,
         "test_statistic" = !is.na(data$lr_statistic) & data$lr_statistic > bound,
         "p_val" = !is.na(data$lr_pvalue) & data$lr_pvalue > bound,
         rep(FALSE, nrow(data))
  )
}

# Helper function: Evaluate efficacy condition
evaluate_efficacy_condition <- function(data, bound, type) {
  switch(type,
         "test_statistic" = !is.na(data$lr_statistic) & data$lr_statistic < bound,
         "p_val" = !is.na(data$lr_pvalue) & data$lr_pvalue < bound,
         rep(FALSE, nrow(data))
  )
}
