#' Overall population statistical analysis summary for clinical trial data
#'
#' This function performs overall population statistical analysis on clinical trial data
#' generated by \code{\link{analysisData}}. It calculates log-rank test statistics,
#' p-values, hazard ratios, patient counts, event counts, and analysis times using
#' data.table for maximum performance.
#'
#' @param data A data.table containing analysis data generated by \code{\link{analysisData}}.
#'   Must contain columns: simID, analysis, group, tte, event, analysis.time.
#' @param control A numeric value indicating which value in \code{group} represents
#'   the control group. Default is 1.
#' @param side A numeric value indicating the type of test: 1 for one-sided test,
#'   2 for two-sided test. Default is 2.
#' @param hr_est_method A character string specifying the hazard ratio estimation method.
#'   Must be one of "PY", "Pike", "Peto", "LR", or "Cox". Default is "Cox".
#'
#' @return A data.table containing overall population analysis results with the following columns:
#' \describe{
#'   \item{simID}{Simulation iteration ID}
#'   \item{analysis}{Analysis number}
#'   \item{subgroup}{Always "Overall" for overall population}
#'   \item{analysis_time}{Analysis cutoff time (calendar time from study start)}
#'   \item{lr_statistic}{Log-rank test statistic}
#'   \item{lr_pvalue}{Log-rank test p-value (one-sided or two-sided based on side parameter)}
#'   \item{hazard_ratio}{Estimated hazard ratio}
#'   \item{hr_method}{Method used for hazard ratio estimation}
#'   \item{n_total}{Total number of patients}
#'   \item{n_control}{Number of patients in control group}
#'   \item{n_treatment}{Number of patients in treatment group}
#'   \item{events_total}{Total number of events}
#'   \item{events_control}{Number of events in control group}
#'   \item{events_treatment}{Number of events in treatment group}
#' }
#'
#' @details
#' This function provides overall population summary of clinical trial results by:
#'
#' \describe{
#'   \item{Log-rank Test}{
#'     Performs log-rank test using \code{\link{lrtest}} for the overall population
#'     at each analysis timepoint. Returns test statistic and p-value based on the side parameter.
#'   }
#'   \item{Hazard Ratio Estimation}{
#'     Calculates hazard ratios using \code{\link{esthr}} for the overall population
#'     using the specified method.
#'   }
#'   \item{Patient and Event Counts}{
#'     Summarizes patient numbers and event numbers by group for the overall population.
#'   }
#'   \item{Analysis Time}{
#'     Records the analysis cutoff time for each analysis.
#'   }
#' }
#'
#' All calculations are performed using data.table for maximum efficiency and are
#' stratified by simulation ID and analysis number.
#'
#' @examples
#' library(data.table)
#'
#' # Generate trial data
#' trial_data <- simTrial(
#'   nsim = 50,
#'   N = list(control = 100, treatment = 100),
#'   a.time = c(0, 18),
#'   intensity = 200/18,
#'   e.time = list(control = c(0, Inf), treatment = c(0, Inf)),
#'   e.hazard = list(control = 0.08, treatment = 0.05),
#'   d.time = list(control = c(0, Inf), treatment = c(0, Inf)),
#'   d.hazard = list(control = 0.01, treatment = 0.01),
#'   seed = 123
#' )
#'
#' # Create analysis datasets
#' analysis_data <- analysisData(trial_data, E = c(50, 100, 150))
#'
#' # Generate overall population summary
#' overall_results <- overallSummary(analysis_data, control = 1, side = 2, hr_est_method = "Cox")
#'
#' # View results for first simulation
#' print(overall_results[simID == 1])
#'
#' @seealso
#' \code{\link{analysisData}} for creating the input analysis datasets,
#' \code{\link{lrtest}} for log-rank test implementation,
#' \code{\link{esthr}} for hazard ratio estimation,
#' \code{\link{subgroupSummary}} for subgroup analysis
#'
#' @import data.table
#' @export
overallSummary <- function(data, control = 1, side = 2, hr_est_method = "Cox") {
  # Input validation
  if (!is.data.table(data)) {
    data <- as.data.table(data)
  }

  required_cols <- c("simID", "analysis", "group", "tte", "event", "analysis.time")
  missing_cols <- setdiff(required_cols, names(data))
  if (length(missing_cols) > 0) {
    stop(paste("Missing required columns:", paste(missing_cols, collapse = ", ")))
  }

  if (!side %in% c(1, 2)) {
    stop("side must be either 1 (one-sided) or 2 (two-sided)")
  }

  valid_methods <- c('PY', 'Pike', 'Peto', 'LR', 'Cox')
  if (!hr_est_method %in% valid_methods) {
    stop(paste("hr_est_method must be one of:", paste(valid_methods, collapse = ", ")))
  }

  # Set key for optimal performance
  setkeyv(data, c("simID", "analysis"))

  # Pre-compute group indicators for efficiency
  data[, `:=`(
    is_control = as.integer(group == control),
    is_treatment = as.integer(group != control)
  )]

  # Pre-compute ranks and event times for each (simID, analysis) combination
  # This is the key optimization - compute ranks once for all combinations
  data[, `:=`(
    time_ranks = rank(tte, ties.method = "min")
  ), by = .(simID, analysis)]

  # Pre-compute unique event times for each (simID, analysis) combination
  event_times_dt <- data[event == 1, .(
    event_times = list(sort(unique(time_ranks)))
  ), by = .(simID, analysis)]

  # Merge event times back to main data
  data <- data[event_times_dt, on = .(simID, analysis)]

  # Helper function for log-rank test computation (optimized)
  compute_lr_stats <- function(tte_vec, event_vec, group_vec, time_ranks_vec, event_times_vec) {
    if (length(unique(group_vec)) != 2 || sum(event_vec) < 2) {
      return(list(lr_statistic = NA_real_, lr_pvalue = NA_real_))
    }

    # Check if both groups have events
    events_by_group <- tapply(event_vec, group_vec, sum)
    if (any(events_by_group == 0)) {
      return(list(lr_statistic = NA_real_, lr_pvalue = NA_real_))
    }

    tryCatch({
      # Use optimized lrtest with pre-computed ranks and event times
      lr_stat <- lrtest(tte_vec, event_vec, group_vec, control, side,
                        time_ranks = time_ranks_vec, event_times = event_times_vec)

      # Calculate p-value based on side parameter
      if (side == 1) {
        # One-sided test: lr_stat is Z-score
        lr_pvalue <- pnorm(lr_stat)
      } else {
        # Two-sided test: lr_stat is chi-square
        lr_pvalue <- 1 - pchisq(lr_stat, 1)
      }

      list(lr_statistic = lr_stat, lr_pvalue = lr_pvalue)
    }, error = function(e) {
      list(lr_statistic = NA_real_, lr_pvalue = NA_real_)
    })
  }

  # Helper function for hazard ratio computation (optimized)
  compute_hr <- function(tte_vec, event_vec, group_vec, time_ranks_vec, event_times_vec) {
    if (length(unique(group_vec)) != 2) {
      return(NA_real_)
    }

    # Check if both groups have events
    events_by_group <- tapply(event_vec, group_vec, sum)
    if (any(events_by_group == 0)) {
      return(NA_real_)
    }

    tryCatch({
      # Use optimized esthr with pre-computed ranks and event times
      hr_result <- esthr(tte_vec, event_vec, group_vec, control, hr_est_method,
                         time_ranks = time_ranks_vec, event_times = event_times_vec)
      hr_result$HR
    }, error = function(e) {
      NA_real_
    })
  }

  # Overall population analysis using data.table operations with pre-computed values
  overall_results <- data[, {
    # Extract first event_times list for this group
    event_times_vec <- event_times[[1]]

    # Basic statistics computed in single pass
    list(
      subgroup = "Overall",
      analysis_time = analysis.time[1L],
      n_total = .N,
      n_control = sum(is_control),
      n_treatment = sum(is_treatment),
      events_total = sum(event),
      events_control = sum(event * is_control),
      events_treatment = sum(event * is_treatment),
      # Compute statistical tests with pre-computed values
      lr_stats = list(compute_lr_stats(tte, event, group, time_ranks, event_times_vec)),
      hazard_ratio = compute_hr(tte, event, group, time_ranks, event_times_vec)
    )
  }, by = .(simID, analysis)]

  # Expand log-rank statistics
  overall_results[, `:=`(
    lr_statistic = sapply(lr_stats, function(x) x$lr_statistic),
    lr_pvalue = sapply(lr_stats, function(x) x$lr_pvalue)
  )]

  # Remove temporary column
  overall_results[, lr_stats := NULL]

  # Add hr_method column
  overall_results[, hr_method := hr_est_method]

  # Remove temporary columns from original data
  data[, `:=`(is_control = NULL, is_treatment = NULL, time_ranks = NULL, event_times = NULL)]

  # Set optimal column order
  setcolorder(overall_results, c("simID", "analysis", "subgroup", "analysis_time",
                                 "lr_statistic", "lr_pvalue", "hazard_ratio", "hr_method",
                                 "n_total", "n_control", "n_treatment",
                                 "events_total", "events_control", "events_treatment"))

  # Sort results for consistency
  setorderv(overall_results, c("simID", "analysis"))

  return(overall_results)
}
