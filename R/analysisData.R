#' Create analysis datasets from clinical trial simulation data
#'
#' This function creates analysis datasets from simulation data generated by simTrial()
#' based on either target number of events or follow-up times for interim and final
#' analyses using tidyverse packages. It handles data cutoffs and censoring
#' appropriately for time-to-event analysis.
#'
#' @param data A tibble containing simulation data generated by \code{\link{simTrial}}.
#'   Must contain columns: simID, group, patientID, accrual.time, surv.time,
#'   dropout.time, tte, total, dropout. May optionally contain subgroup column.
#' @param E A numeric vector specifying the target number of events for each analysis.
#'   Each element represents a different analysis timepoint (e.g., interim, final).
#'   Cannot be used with followup. Default is NULL.
#' @param followup A numeric vector specifying the follow-up times for each analysis.
#'   Each element represents the calendar time from study start for analysis.
#'   Cannot be used with E. Default is NULL.
#'
#' @return A tibble containing the analysis datasets with the following columns:
#' \describe{
#'   \item{analysis}{Analysis number (1, 2, 3, ...) corresponding to each element in E or followup}
#'   \item{simID}{Simulation iteration ID (1 to nsim)}
#'   \item{group}{Group indicator (1, 2, 3, ...)}
#'   \item{subgroup}{Subgroup indicator (A, B, C, ...) - only present if subgroups are specified}
#'   \item{patientID}{Patient ID within each group/subgroup combination}
#'   \item{accrual.time}{Patient accrual time from study start}
#'   \item{surv.time}{Original survival time from patient entry}
#'   \item{dropout.time}{Original dropout time from patient entry}
#'   \item{tte}{Time-to-event (adjusted for analysis cutoff)}
#'   \item{total}{Original total time from study start}
#'   \item{dropout}{Original dropout indicator from simTrial}
#'   \item{analysis.time}{Analysis cutoff time (calendar time from study start)}
#'   \item{event}{Event indicator for analysis (1 = event occurred by cutoff, 0 = censored at cutoff)}
#' }
#'
#' @details
#' This function is essential for simulating adaptive trial designs and interim analyses.
#' It supports two main approaches:
#'
#' \describe{
#'   \item{Event-driven Analysis (E parameter)}{
#'     Analysis is triggered when a target number of events is observed across all
#'     groups. The analysis time is determined as the calendar time when the E-th
#'     event occurs. This is common in oncology trials where analyses are performed
#'     after accumulating a predetermined number of deaths.
#'   }
#'   \item{Time-driven Analysis (followup parameter)}{
#'     Analysis is performed at predetermined calendar times from study start,
#'     regardless of the number of events observed. This is common in cardiovascular
#'     trials with planned interim analyses at fixed timepoints.
#'   }
#' }
#'
#' For each analysis, the function:
#' \itemize{
#'   \item Determines the appropriate analysis cutoff time
#'   \item Adjusts time-to-event data for patients not yet recruited at cutoff
#'   \item Censors events occurring after the cutoff time
#'   \item Creates appropriate event indicators for statistical analysis
#' }
#'
#' The resulting dataset can be used directly with survival analysis functions
#' like \code{\link{lrtest}} and \code{\link{esthr}}.
#'
#' @examples
#' library(dplyr)
#'
#' # Generate trial data for analysis
#' trial_data <- simTrial(
#'   nsim = 100,
#'   n = list(
#'     control = c(A = 25, B = 112, C = 113),
#'     treatment = c(A = 25, B = 112, C = 113)
#'   ),
#'   a.time = c(0, 12.5),
#'   intensity = 40,
#'   e.time = list(
#'     control = list(A = c(0, Inf), B = c(0, Inf), C = c(0, Inf)),
#'     treatment = list(A = c(0, Inf), B = c(0, Inf), C = c(0, Inf))
#'   ),
#'   e.hazard = list(
#'     control = list(A = log(2) / 4.3, B = log(2) / 4.3, C = log(2) / 4.3),
#'     treatment = list(A = log(2) / 5.811, B = log(2) / 5.811, C = log(2) / 5.811)
#'   ),
#'   d.time = NULL,
#'   d.hazard = NULL,
#'   seed = 1
#' )
#'
#' # Example 1: Event-driven analyses
#' # Interim at 141 events, interim at 246 events, final at 352 events
#' analysis_events <- analysisData(trial_data, E = c(141, 246, 352))
#'
#' # Check event counts by analysis
#' event_summary <- analysis_events %>%
#'   group_by(analysis, simID) %>%
#'   summarise(
#'     total_events = sum(event),
#'     total_patients = n(),
#'     analysis_time = unique(analysis.time),
#'     .groups = 'drop'
#'   )
#'
#' print(event_summary[event_summary$simID == 1, ])  # Show first simulation
#'
#' # Example 2: Time-driven analyses
#' # Analyses at 15, 20, and 25 months from study start
#' analysis_time <- analysisData(trial_data, followup = c(15, 20, 25))
#'
#' # Compare event counts between event-driven and time-driven
#' time_events <- analysis_time %>%
#'   group_by(analysis, simID) %>%
#'   summarise(
#'     total_events = sum(event),
#'     total_patients = n(),
#'     analysis_time = unique(analysis.time),
#'     .groups = 'drop'
#'   )
#'
#' print(time_events[time_events$simID == 1, ])
#'
#' @seealso
#' \code{\link{simTrial}} for generating the input trial data,
#' \code{\link{lrtest}} and \code{\link{esthr}} for statistical analysis
#'
#' @import dplyr
#' @export
analysisData <- function(data, E = NULL, followup = NULL) {

  # Input validation
  if (is.null(E) && is.null(followup)) {
    stop("Either E or followup must be specified")
  }

  if (!is.null(E) && !is.null(followup)) {
    stop("Cannot specify both E and followup arguments")
  }

  # Ensure data is a tibble/data.frame
  if (!inherits(data, c("tbl_df", "tbl", "data.frame"))) {
    stop("data must be a tibble or data.frame generated by simTrial")
  }

  # Check required columns
  required_cols <- c("simID", "group", "patientID", "accrual.time",
                     "surv.time", "dropout.time", "tte", "total", "dropout")
  missing_cols <- setdiff(required_cols, names(data))
  if (length(missing_cols) > 0) {
    stop(paste("Missing required columns:", paste(missing_cols, collapse = ", ")))
  }

  # Check if subgroups exist
  has_subgroups <- "subgroup" %in% names(data)

  # Sort data by simulation ID and total time for efficient processing
  data <- data %>%
    arrange(simID, total)

  if (!is.null(E)) {
    # Event-driven analysis
    analysis_data <- create_event_driven_analysis(data, E, has_subgroups)
  } else {
    # Time-driven analysis
    analysis_data <- create_time_driven_analysis(data, followup, has_subgroups)
  }

  return(analysis_data)
}

# Helper function: Create event-driven analysis data
create_event_driven_analysis <- function(data, E, has_subgroups) {

  n_analyses <- length(E)
  all_analysis_data <- list()

  for (analysis_num in seq_len(n_analyses)) {
    target_events <- E[analysis_num]

    # For each simulation, find the analysis time when target_events occur
    analysis_times <- data %>%
      filter(dropout == 0) %>%  # Only count actual events (not dropouts)
      group_by(simID) %>%
      arrange(total) %>%
      slice_head(n = target_events) %>%
      slice_tail(n = 1) %>%
      select(simID, analysis_time = total) %>%
      ungroup()

    # Create analysis dataset for this analysis
    analysis_subset <- data %>%
      left_join(analysis_times, by = "simID") %>%
      filter(!is.na(analysis_time)) %>%
      mutate(
        # Adjust tte for analysis cutoff
        tte_adjusted = ifelse(total > analysis_time,
                              analysis_time - accrual.time,
                              tte),
        # Create event indicator
        event = as.numeric(total <= analysis_time & dropout == 0),
        # Add analysis number and rename analysis_time column
        analysis = analysis_num,
        analysis.time = analysis_time
      ) %>%
      # Keep only patients who were recruited by analysis time
      filter(accrual.time <= analysis.time) %>%
      # Update tte to adjusted value
      mutate(tte = tte_adjusted) %>%
      select(-tte_adjusted, -analysis_time)  # Remove temporary column

    all_analysis_data[[analysis_num]] <- analysis_subset
  }

  # Combine all analyses
  final_data <- bind_rows(all_analysis_data)

  # Set column order
  if (has_subgroups) {
    final_data <- final_data %>%
      select(analysis, simID, group, subgroup, patientID, accrual.time,
             surv.time, dropout.time, tte, total, dropout, analysis.time, event)
  } else {
    final_data <- final_data %>%
      select(analysis, simID, group, patientID, accrual.time, surv.time,
             dropout.time, tte, total, dropout, analysis.time, event)
  }

  return(final_data)
}

# Helper function: Create time-driven analysis data
create_time_driven_analysis <- function(data, followup, has_subgroups) {

  n_analyses <- length(followup)
  all_analysis_data <- list()

  for (analysis_num in seq_len(n_analyses)) {
    analysis_time <- followup[analysis_num]

    # Create analysis dataset for this analysis
    analysis_subset <- data %>%
      filter(accrual.time <= analysis_time) %>%  # Only patients recruited by analysis time
      mutate(
        # Adjust tte for analysis cutoff
        tte_adjusted = ifelse(total > analysis_time,
                              analysis_time - accrual.time,
                              tte),
        # Create event indicator
        event = as.numeric(total <= analysis_time & dropout == 0),
        # Add analysis information
        analysis = analysis_num,
        analysis.time = analysis_time
      ) %>%
      # Update tte to adjusted value
      mutate(tte = tte_adjusted) %>%
      select(-tte_adjusted)

    all_analysis_data[[analysis_num]] <- analysis_subset
  }

  # Combine all analyses
  final_data <- bind_rows(all_analysis_data)

  # Set column order
  if (has_subgroups) {
    final_data <- final_data %>%
      select(analysis, simID, group, subgroup, patientID, accrual.time,
             surv.time, dropout.time, tte, total, dropout, analysis.time, event)
  } else {
    final_data <- final_data %>%
      select(analysis, simID, group, patientID, accrual.time, surv.time,
             dropout.time, tte, total, dropout, analysis.time, event)
  }

  return(final_data)
}
