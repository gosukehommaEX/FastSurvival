#' Create analysis datasets from clinical trial simulation data
#'
#' This function creates analysis datasets from simulation data generated by \code{\link{simTrialData}}
#' based on either target number of events or follow-up times for interim and final
#' analyses. It handles data cutoffs and censoring appropriately for time-to-event analysis.
#'
#' @param data A tibble containing simulation data generated by \code{\link{simTrialData}}.
#'   Must contain columns: simID, patientID, group, accrual.time, survival.time,
#'   dropout.time, tte, total, dropout. May optionally contain subgroup column.
#' @param E A numeric vector specifying the target number of events for each analysis.
#'   Each element represents a different analysis timepoint (e.g., interim, final).
#'   Cannot be used with followup. Default is NULL.
#' @param followup A numeric vector specifying the follow-up times for each analysis.
#'   Each element represents the calendar time from study start for analysis.
#'   Cannot be used with E. Default is NULL.
#'
#' @return A tibble containing the analysis datasets with the following columns:
#' \describe{
#'   \item{simID}{Simulation iteration ID (1 to nsim)}
#'   \item{analysis}{Analysis number (1, 2, 3, ...) corresponding to each element in E or followup}
#'   \item{patientID}{Patient ID within each simulation}
#'   \item{accrual.time}{Patient accrual time from study start}
#'   \item{survival.time}{Original survival time from patient entry}
#'   \item{dropout.time}{Original dropout time from patient entry}
#'   \item{tte}{Time-to-event (adjusted for analysis cutoff)}
#'   \item{total}{Original total time from study start}
#'   \item{analysis.time}{Analysis cutoff time (calendar time from study start)}
#'   \item{dropout}{Original dropout indicator from simTrialData}
#'   \item{event}{Event indicator for analysis (1 = event occurred by cutoff, 0 = censored at cutoff)}
#'   \item{group}{Group indicator (control, treatment, etc.)}
#'   \item{subgroup}{Subgroup indicator (A, B, C, ...) - only present if subgroups are specified}
#' }
#'
#' @details
#' This function is essential for simulating adaptive trial designs and interim analyses.
#' It supports two main approaches:
#'
#' \describe{
#'   \item{Event-driven Analysis (E parameter)}{
#'     Analysis is triggered when a target number of events is observed across all
#'     groups. The analysis time is determined as the calendar time when the E-th
#'     event occurs. This is common in oncology trials where analyses are performed
#'     after accumulating a predetermined number of deaths.
#'   }
#'   \item{Time-driven Analysis (followup parameter)}{
#'     Analysis is performed at predetermined calendar times from study start,
#'     regardless of the number of events observed. This is common in cardiovascular
#'     trials with planned interim analyses at fixed timepoints.
#'   }
#' }
#'
#' For each analysis, the function:
#' \itemize{
#'   \item Determines the appropriate analysis cutoff time
#'   \item Adjusts time-to-event data for patients not yet recruited at cutoff
#'   \item Censors events occurring after the cutoff time
#'   \item Creates appropriate event indicators for statistical analysis
#' }
#'
#' The resulting dataset can be used directly with survival analysis functions
#' like \code{\link{lrtest}} and \code{\link{esthr}}.
#'
#' @examples
#' library(dplyr)
#'
#' # Generate trial data for analysis
#' trial_data <- simTrialData(
#'   nsim = 100,
#'   n = list(control = 250, treatment = 250),
#'   a.dist = 'pieceunif',
#'   a.time = c(0, 5, 10, 15, 20, 25),
#'   proportion = c(0.05, 0.1, 0.15, 0.3, 0.4),
#'   e.time = list(control = c(0, Inf), treatment = c(0, Inf)),
#'   e.hazard = list(control = log(2) / 4.3, treatment = log(2) / 5.811),
#'   d.time = list(control = c(0, Inf), treatment = c(0, Inf)),
#'   d.hazard = list(control = -log(1 - 0.1) / 12, treatment = -log(1 - 0.1) / 12),
#'   seed = 1
#' )
#'
#' # Example 1: Event-driven analyses
#' # Interim at 141 events, interim at 246 events, final at 352 events
#' analysis_events <- analysisData(trial_data, E = c(141, 246, 352))
#'
#' # Check event counts by analysis
#' event_summary <- analysis_events %>%
#'   group_by(analysis, simID) %>%
#'   summarise(
#'     total_events = sum(event),
#'     total_patients = n(),
#'     analysis_time = unique(analysis.time),
#'     .groups = 'drop'
#'   )
#'
#' print(event_summary[event_summary$simID == 1, ])  # Show first simulation
#'
#' # Example 2: Time-driven analyses
#' # Analyses at 15, 20, and 25 months from study start
#' analysis_time <- analysisData(trial_data, followup = c(15, 20, 25))
#'
#' # Compare event counts between event-driven and time-driven
#' time_events <- analysis_time %>%
#'   group_by(analysis, simID) %>%
#'   summarise(
#'     total_events = sum(event),
#'     total_patients = n(),
#'     analysis_time = unique(analysis.time),
#'     .groups = 'drop'
#'   )
#'
#' print(time_events[time_events$simID == 1, ])
#'
#' @seealso
#' \code{\link{simTrialData}} for generating the input trial data,
#' \code{\link{lrtest}} and \code{\link{esthr}} for statistical analysis
#'
#' @import dplyr
#' @export
analysisData <- function(data, E = NULL, followup = NULL) {

  # Input validation
  if (is.null(E) && is.null(followup)) {
    stop("Either E or followup must be specified")
  }

  if (!is.null(E) && !is.null(followup)) {
    stop("Cannot specify both E and followup arguments")
  }

  # Ensure data is a tibble/data.frame
  if (!inherits(data, c("tbl_df", "tbl", "data.frame"))) {
    stop("data must be a tibble or data.frame generated by simTrialData")
  }

  # Check required columns
  required_cols <- c("simID", "patientID", "group", "accrual.time", "survival.time",
                     "dropout.time", "tte", "total", "dropout")
  missing_cols <- setdiff(required_cols, names(data))
  if (length(missing_cols) > 0) {
    stop(paste("Missing required columns:", paste(missing_cols, collapse = ", ")))
  }

  if (!is.null(E)) {
    # Event-driven analysis based on original code structure with minimal optimization
    # Pre-compute sequence once to avoid repeated seq_along calls
    E_seq <- seq_along(E)

    analysis_data <- do.call(
      bind_rows,
      lapply(E_seq, function(i) {
        data %>%
          arrange(simID, total) %>%
          group_by(simID) %>%
          mutate(
            analysis = i,
            analysis.time = total[dropout != 1][E[i]],
            tte = (total > analysis.time) * (analysis.time - accrual.time) + (total <= analysis.time) * tte,
            event = as.numeric(total <= analysis.time & dropout != 1)
          ) %>%
          filter(tte >= 0) %>%
          ungroup()
      })
    )
  } else {
    # Time-driven analysis using followup times with minimal optimization
    # Pre-compute sequence once to avoid repeated seq_along calls
    followup_seq <- seq_along(followup)

    analysis_data <- do.call(
      bind_rows,
      lapply(followup_seq, function(i) {
        data %>%
          arrange(simID, total) %>%
          mutate(
            analysis = i,
            analysis.time = followup[i],
            tte = (total > analysis.time) * (analysis.time - accrual.time) + (total <= analysis.time) * tte,
            event = as.numeric(total <= analysis.time & dropout != 1)
          ) %>%
          filter(tte >= 0)
      })
    )
  }

  # Select and reorder columns with group placed after patientID
  analysis_data <- analysis_data %>%
    select(simID, analysis, patientID, group, accrual.time, survival.time, dropout.time,
           tte, total, analysis.time, dropout, event)

  return(analysis_data)
}
